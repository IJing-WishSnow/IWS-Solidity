# 跨服重入攻击

所谓“跨服”，是对这一类型的攻击目标的生动概括，因为它们共同的手段是从某一个函数开始入手，但是攻击对象却是其他函数/合约/项目等等。

1. 跨函数重入攻击
    攻击者重入的不再是withdraw函数，而是转头去重入没有戴锁的transfer函数

2. 跨合约重入攻击
    如何做到：俗话说得好， “灯下黑“ ，答案就在最表面上反而容易被忽视 --- 因为这是 两 个 合 约...锁的状态是不互通的！ 

    全局重入锁：建立一个单独的合约用来储存重入状态，然后，在你的系统里的任何合约里相关的函数在执行的时候，都要来这同一个地方来查看当前的重入状态，这样你的所有合约就都被重入保护起来了

3. 跨项目重入攻击
    本质就是趁某项目合约的某个状态变量在还未来得及更新时，就利用接手的执行权来发起外部函数调用。如果有第三方合作项目的合约是依赖于前面提到的项目合约里这个状态变量的值来做某些决策的，那么攻击者就可以去攻击这个合作项目的合约，因为在此刻它读到的是一个过期的状态值，会导致它执行一些错误的行为令攻击者获利。 通常，合作项目的合约通过一些getter函数或其他公开的只读函数的调用来传递信息，所以这类攻击也通常体现为只读重入攻击 Read-Only Reentrancy

4. ERC721 & ERC777 Reentrancy

    这两种代币标准都各自规定了一个回调函数：

    ERC721: function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public returns(bytes4);  

    ERC777: function tokensReceived(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;  

    有回调函数的存在就有接手代码执行权的机会，同时也会营造出重入攻击的可能性。

## 总结

简单的工具永远不会是完美防御，贯彻的方法论才是你永远的后盾

对于使用小工具，还是使用方法论的取舍，我们作为solidity devs，答案我想应该是：既要...又要...！从跨函数的攻击，再到跨合约，跨项目的攻击，若是要求devs和auditors记住这越来越庞大的乐高之间的千丝万缕的联系，实在是有些强人所难。于是，在构造过程中的每一步，都标准地布置多道不同防御机制，便能省心地获得更好的结果。