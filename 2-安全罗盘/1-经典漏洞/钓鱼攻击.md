# tx.origin钓鱼攻击

在solidity中，使用tx.origin可以获得启动交易的原始地址，它与msg.sender十分相似。
区别：如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，msg.sender就是B合约，而tx.origin就是用户A。


## 预防办法
目前主要有两种办法来预防可能的tx.origin钓鱼攻击。

1.使用msg.sender代替tx.origin
msg.sender能够获取直接调用当前合约的调用发送者地址，通过对msg.sender的检验，就可以避免整个调用过程中混入外部攻击合约对当前合约的调用

function transfer(address payable _to, uint256 _amount) public {
  require(msg.sender == owner, "Not owner");

  (bool sent, ) = _to.call{value: _amount}("");
  require(sent, "Failed to send Ether");
}
2.检验tx.origin == msg.sender
如果一定要使用tx.origin，那么可以再检验tx.origin是否等于msg.sender，这样也可以避免整个调用过程中混入外部攻击合约对当前合约的调用。但是副作用是其他合约将不能调用这个函数。

    function transfer(address payable _to, uint _amount) public {
        require(tx.origin == owner, "Not owner");
        require(tx.origin == msg.sender, "can't call by external contract");
        (bool sent, ) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }

## 总结：
智能合约中的tx.origin钓鱼攻击，目前有两种方法可以预防它：一种是使用msg.sender代替tx.origin；另一种是同时检验tx.origin == msg.sender。推荐使用第一种方法预防，因为后者会拒绝所有来自其他合约的调用。
