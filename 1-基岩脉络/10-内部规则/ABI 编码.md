<!-- markdownlint-disable MD033 -->
# ABI编码

合约ABI规范是在以太坊生态系统中与合约交互的标准方式，包括从区块链外部和合约间的交互。其中很重要的一项就是数据编码和解码：Solidity合约中的函数参数（calldata）和返回值（returndata）可能具有复杂的数据结构，包括结构体、数组和映射等。ABI 规范定义了如何对这些数据进行编码和解码，以便在合约之间传递和解释数据。这使得合约能够正确处理不同数据类型和数据结构，确保数据的完整性和一致性。

## 静态类型的ABI编码规范

1. uint<M>: M位的无符号整数，M的取值为0到256之间的可以整除8的整数，比如uint8，uint32，uint256（uint是uint256的同义词）。编码时，会在它们左侧补充若干0以使其长度成为32字节。

2. address: 与uint160的编码方式相同。address payable和contract类型的变量也使用相同的编码方式。

3. bool: 1表示true，0表示false，编码方式与uint8的情况相同。

4. bytes<M>：长度为M字节的字节数组，0 < M <= 32，编码时会在右侧补若干0使其长度成为32字节。

5. 静态定长数组T[k]: T为静态类型，比如uint，k为定长数组的长度，是正整数。它就像先将相同类型的k个元素分别编码，再顺序拼接到一起。

6. 静态元组(T1,...,Tk): T1,...,Tk均为静态类型，它先将k个元素分别编码，再顺序拼接到一起。

## 动态类型的ABI编码

1. 动态数组：编码时当前数据槽记录偏移量，然后记录动态数组的长度和每一个元素，它们分别占据一个单独的数据槽（32字节）。

2. bytes和string：编码时与动态数组相同，会在当前数据槽记录分配位置的偏移量，然后在分配的位置记录bytes/string的字节长度，接下来是字节内容，编码时会在右侧补若干0使其长度成为32字节的倍数。

3. 动态类型的定长数组：比如string[2]，会在当前数据槽记录分配位置的偏移量，然后再在之后的槽中记录每个元素的偏移量，比如strings[0]和strings[1]的偏移量，最后记录元素的值。

4. 包含动态类型的元组/结构体：元组和结构体的编码方式相同，对于包含动态类型的元组/结构体，会在当前数据槽记录分配位置的偏移量，然后再分别编码成员：如果成员是静态类型，就直接在当前槽中编码；如果是动态类型，则先记录偏移量，再在后面分配的位置进行编码。

5. 动态类型的不定长数组：偏移量，长度，元素偏移量，动态类型的长度和元素内容

## ABI编码公式

    公式会使用到的符号的意义：

    T: 任意变量类型。
    (T1, T2,...,Tn): 由T1...Tn等类型的变量组成的元组。
    len(a): a的字节长度，用于计算数据偏移量。
    e(X): 变量X的 ABI 编码。
    head(X): X变量的头部编码。
    tail(X): X变量的尾部编码。
    pad_right(X): 在X的值的右侧补若干个0，使其长度成为32字节。

1. 递归编码公式

    元组（结构体也会转换成元组进行编码）：元组X的编码由两部分组成，第一部分是头部编码，第二部分是尾部编码，它们都按照元素在元组中的顺序排列。如果X(i)的类型Ti为静态类型，则直接在头部进行编码，没有尾部编码；如果X(i)的类型Ti为动态类型，那么会在尾部进行编码，头部编码为尾部编码tail(X(i))的偏移量。

    定长数组：当作由相同类型的k个元素组成的元组那样被编码的。

    不定长数组：编码有两部分，第一部分为长度k的编码，第二部分为等效的定长数组的编码。

2. 类型编码公式

    uint<M>：M位的无符号整数，M的取值为0到256之间的可以整除 8 的整数，比如uint8，uint32，uint256（uint是uint256的同义词）。编码时，会在它们左侧补充若干0以使其长度成为32字节。

    address：地址类型，与uint160的编码方式相同。address payable和contract类型的变量也使用相同的编码方式。

    bool: 1表示true，0表示false，编码方式与uint8的情况相同。

    bytes<M>：长度为M字节的定长字节数组，0 < M <= 32，编码时会在右侧补若干0使其长度成为32字节。

    bytes: 若X是长度为k（k的类型为uint256）的不定长字节数组，则enc(X) = enc(k) pad_right(X)，也就是先编码长度k，再编码内容。编码内容时会在右侧补若干0使其长度成为32字节的倍数。

    string: 会先用UTF-8编码为bytes，然后使用bytes的规则进行 ABI 编码。

## calldata/returndata的ABI编码

    calldata：函数选择器 输入参数编码
    returndata： 返回参数编码

## 事件的ABI编码

    address: 合约的地址，自动从EVM读取，不需要开发者提供。对于Transfer事件，address就是该ERC20的合约地址

    topics[0]: 第一个主题为32字节的事件哈希，也就是事件签名的keccak256哈希。与函数选择器类似，但它是32字节，而非4字节。举个例子，Transfer事件的事件哈希为（uint要写成uint256）：

    keccak256("Transfer(address,address,uint256)")

    //0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    topics[n]: 第n个主题保存事件中第n-1个indexed字段。以Transfer事件为例，它的第2个主题就是from地址，第3个主题就是to地址。对于简单类型，它们会以ABI编码规则进行编码，直接保存在主题中；对于复杂类型，比如string/bytes/数组/结构体，按照特定的方式进行编码（与ABI编码有所不同，后面会讲），计算keccak256哈希，最后把哈希保存在主题中。

    data: 事件的数据部分就是把所有非indexed数据组成的元组进行ABI编码并保存

### 复杂类型的主题编码

    bytes和string：只保存字符串的内容，没有任何填充或长度前缀
    struct结构体的编码时其成员编码的串联，其中每个成员都会填充为32字节的倍数（包括bytes/string成员）。
    数组（包括静态和动态）仅是其元素编码的串联，不包含任何数组长度或偏移量的前缀，其中每个成员都会填充为32字节的倍数（包括bytes/string成员）。

### 匿名事件

    匿名事件（anonymous event）是一种特殊的事件，不常用。它的日志中不存储事件哈希，因此它最多可以拥有4个indexed参数。需要用anonymous关键字声明它：

## Error的ABI编码

    错误信息的编码方式与calldata一致。
    自定义错误：编码由error关键字定义的自定义错误信息时，前4字节为错误选择器。错误选择器与函数选择器类似，是错误签名的Keccak256哈希的前4字节。
    require 和 assert：Solidity规定了它们的错误签名为Error(string)，对应的选择器为0x08c379a0。
    