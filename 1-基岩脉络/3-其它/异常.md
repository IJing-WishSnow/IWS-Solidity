# 异常

写智能合约经常会出bug，Solidity中的异常命令帮助我们debug。

## Error

error是solidity 0.8.4版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数，帮助开发者更好地调试。人们可以在contract之外定义异常。

```solidity
error TransferNotOwner(); // 自定义error

// 我们也可以定义一个携带参数的异常，来提示尝试转账的账户地址
error TransferNotOwner(address sender); // 自定义的带参数的error

// 在执行当中，error必须搭配revert（回退）命令使用。
function transferOwner1(uint256 tokenId, address newOwner) public {
    if(_owners[tokenId] != msg.sender){
        revert TransferNotOwner();
        // revert TransferNotOwner(msg.sender);
    }
    _owners[tokenId] = newOwner;
}
```

## Require

require命令是solidity 0.8版本之前抛出异常的常用方法。

```solidity
function transferOwner2(uint256 tokenId, address newOwner) public {
    require(_owners[tokenId] == msg.sender, "Transfer Not Owner");
    _owners[tokenId] = newOwner;
}
```


## Assert

assert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。

我们用assert命令重写一下上面的transferOwner1函数：

```solidity
function transferOwner3(uint256 tokenId, address newOwner) public {
    assert(_owners[tokenId] == msg.sender);
    _owners[tokenId] = newOwner;
}
```

## 三种方法的gas比较

error方法gas消耗：24457 (加入参数后gas消耗：24660)
require方法gas消耗：24755
assert方法gas消耗：24473

error方法gas最少，其次是assert，require方法消耗gas最多！
因此，error既可以告知用户抛出异常的原因，又能省gas，要多用！

## Solidity 自定义错误完整指南

## 1. Solidity 自定义错误定义

### 基本语法

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ErrorExamples {
    // 1. 简单错误
    error Unauthorized();
    error InsufficientBalance();
    
    // 2. 带参数的错误
    error InsufficientBalance(uint256 available, uint256 required);
    error TransferFailed(address from, address to, uint256 amount);
    
    // 3. 复杂错误
    error TradeReverted(
        address trader,
        address tokenIn,
        address tokenOut, 
        uint256 amountIn,
        uint256 amountOut,
        bytes32 reason
    );
    
    // 4. 错误枚举
    enum ErrorType {
        ZeroAddress,
        InsufficientBalance,
        DeadlineExpired,
        SlippageExceeded
    }
    error CategorizedError(ErrorType errorType, bytes data);
}
```

### 实际使用示例

```solidity
contract Token {
    mapping(address => uint256) public balanceOf;
    address public owner;
    
    error Unauthorized(address caller);
    error InsufficientBalance(uint256 available, uint256 required);
    error InvalidAddress(address provided);
    error AmountTooSmall(uint256 minAmount, uint256 provided);
    error DeadlineExpired(uint256 deadline, uint256 currentTime);
    
    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert Unauthorized(msg.sender);
        }
        _;
    }
    
    function transfer(address to, uint256 amount) public {
        // 各种错误检查
        if (to == address(0)) {
            revert InvalidAddress(to);
        }
        
        if (amount > balanceOf[msg.sender]) {
            revert InsufficientBalance(balanceOf[msg.sender], amount);
        }
        
        if (amount < 1 ether) {
            revert AmountTooSmall(1 ether, amount);
        }
        
        // 业务逻辑
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
    }
    
    function swap(
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline
    ) public {
        if (block.timestamp > deadline) {
            revert DeadlineExpired(deadline, block.timestamp);
        }
        
        // 交换逻辑...
    }
}
```

## 2. Viem 前端处理自定义错误

### 安装和配置

```bash
npm install viem
```

### 基础错误处理

```typescript
import { createPublicClient, createWalletClient, http, decodeErrorResult } from 'viem'
import { mainnet } from 'viem/chains'

const client = createWalletClient({
  chain: mainnet,
  transport: http()
})

const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})
```

### 完整的错误处理流程

```typescript
import { 
  createWalletClient, 
  http, 
  decodeErrorResult,
  custom 
} from 'viem'
import { mainnet } from 'viem/chains'

// 1. 定义合约 ABI（必须包含错误定义）
const TOKEN_ABI = [
  // 函数定义
  {
    name: 'transfer',
    type: 'function',
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    outputs: [{ type: 'bool' }]
  },
  // 错误定义
  {
    type: 'error',
    name: 'Unauthorized',
    inputs: [
      { name: 'caller', type: 'address' }
    ]
  },
  {
    type: 'error',
    name: 'InsufficientBalance',
    inputs: [
      { name: 'available', type: 'uint256' },
      { name: 'required', type: 'uint256' }
    ]
  },
  {
    type: 'error', 
    name: 'InvalidAddress',
    inputs: [
      { name: 'provided', type: 'address' }
    ]
  }
] as const

// 2. 错误消息映射
const ERROR_MESSAGES = {
  Unauthorized: (args: any) => 
    `地址 ${args.caller} 无权限执行此操作`,
  
  InsufficientBalance: (args: any) => 
    `余额不足。当前余额: ${args.available}，需要: ${args.required}`,
  
  InvalidAddress: (args: any) =>
    `无效地址: ${args.provided}`,
  
  AmountTooSmall: (args: any) =>
    `金额过小。最小金额: ${args.minAmount}，提供金额: ${args.provided}`
}

// 3. 错误处理工具函数
function handleCustomError(error: any, abi: any) {
  try {
    // 检查是否有错误数据
    if (!error.data && !error.cause?.data) {
      return '未知错误：无错误数据'
    }

    const errorData = error.data || error.cause?.data
    
    // 解码错误
    const decodedError = decodeErrorResult({
      abi: abi,
      data: errorData
    })

    // 获取用户友好的错误消息
    const messageHandler = ERROR_MESSAGES[decodedError.errorName as keyof typeof ERROR_MESSAGES]
    if (messageHandler) {
      return messageHandler(decodedError.args)
    }

    return `合约错误: ${decodedError.errorName}`
    
  } catch (decodeError) {
    console.error('错误解码失败:', decodeError)
    return '无法解析的错误信息'
  }
}

// 4. 交易执行函数
async function executeTransfer(
  contractAddress: `0x${string}`,
  toAddress: `0x${string}`, 
  amount: bigint
) {
  try {
    const hash = await client.writeContract({
      address: contractAddress,
      abi: TOKEN_ABI,
      functionName: 'transfer',
      args: [toAddress, amount]
    })

    // 等待交易确认
    const receipt = await publicClient.waitForTransactionReceipt({ hash })
    console.log('转账成功!', receipt)
    
    return { success: true, hash }

  } catch (error: any) {
    // 处理自定义错误
    const userMessage = handleCustomError(error, TOKEN_ABI)
    
    console.error('转账失败:', userMessage)
    console.error('原始错误:', error)
    
    return { 
      success: false, 
      error: userMessage,
      rawError: error 
    }
  }
}
```

### 模拟调用错误处理

```typescript
// 预执行检查（不会上链）
async function simulateTransfer(
  contractAddress: `0x${string}`,
  toAddress: `0x${string}`,
  amount: bigint,
  fromAddress: `0x${string}`
) {
  try {
    const { result } = await publicClient.simulateContract({
      address: contractAddress,
      abi: TOKEN_ABI,
      functionName: 'transfer',
      args: [toAddress, amount],
      account: fromAddress
    })
    
    return { success: true, result }
    
  } catch (error: any) {
    const userMessage = handleCustomError(error, TOKEN_ABI)
    return { success: false, error: userMessage }
  }
}
```

### React Hook 封装

```typescript
import { useState } from 'react'
import { useAccount, useWalletClient } from 'wagmi'

export function useTokenTransfer() {
  const [isLoading, setIsLoading] = useState(false)
  const { address } = useAccount()
  const { data: walletClient } = useWalletClient()

  const transfer = async (
    contractAddress: `0x${string}`,
    toAddress: `0x${string}`,
    amount: bigint
  ) => {
    if (!walletClient || !address) {
      throw new Error('钱包未连接')
    }

    setIsLoading(true)
    
    try {
      // 1. 先模拟执行
      const simulation = await simulateTransfer(
        contractAddress,
        toAddress,
        amount,
        address
      )
      
      if (!simulation.success) {
        throw new Error(simulation.error)
      }

      // 2. 实际执行
      const result = await executeTransfer(contractAddress, toAddress, amount)
      return result
      
    } catch (error: any) {
      throw new Error(error.message || '转账失败')
    } finally {
      setIsLoading(false)
    }
  }

  return { transfer, isLoading }
}
```

### 在 React 组件中使用

```tsx
import React, { useState } from 'react'
import { useTokenTransfer } from './hooks/useTokenTransfer'

function TransferComponent() {
  const [toAddress, setToAddress] = useState('')
  const [amount, setAmount] = useState('')
  const [message, setMessage] = useState('')
  
  const { transfer, isLoading } = useTokenTransfer()

  const handleTransfer = async () => {
    setMessage('')
    
    try {
      const result = await transfer(
        '0xTokenAddress', 
        toAddress as `0x${string}`,
        BigInt(amount)
      )
      
      if (result.success) {
        setMessage('转账成功!')
      } else {
        setMessage(`失败: ${result.error}`)
      }
    } catch (error: any) {
      setMessage(`错误: ${error.message}`)
    }
  }

  return (
    <div>
      <input 
        value={toAddress}
        onChange={(e) => setToAddress(e.target.value)}
        placeholder="收款地址"
      />
      <input 
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="金额"
      />
      <button onClick={handleTransfer} disabled={isLoading}>
        {isLoading ? '处理中...' : '转账'}
      </button>
      {message && <p>{message}</p>}
    </div>
  )
}
```

## 3. 最佳实践总结

### Solidity 端：

- 使用**语义化的错误名称**
- 通过**错误参数**传递上下文信息
- 避免使用字符串参数（Gas 成本高）
- 分类定义错误类型

### 前端 Viem 端：

- 在 ABI 中**包含错误定义**
- 使用 `decodeErrorResult` 解码错误
- 创建**错误消息映射**实现用户友好提示
- 使用 `simulateContract` 进行预检查
- 完整的**错误边界处理**

### 优势：

1. **Gas 高效** - 比 require 带字符串节省大量 Gas
2. **类型安全** - 编译时错误检查
3. **信息丰富** - 通过参数传递详细上下文
4. **前端友好** - 结构化数据便于处理和显示

这样实现了从合约到前端的完整错误处理链路，提供良好的用户体验和开发体验。

